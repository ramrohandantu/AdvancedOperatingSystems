import java.io.*;
import java.net.*;
import java.util.*;
import java.util.concurrent.*;



public class Project3
{
	public static int port;
	public static int nodes;
	public static int numMessages;
	public static int delay;
	public static int nodeId;
	public static int minPerActive;
	public static int maxPerActive;
	public static int minSendDelay;
	public static int snapshotDelay;
	public static int maxNumber;
	public static boolean[] leaf;
	public static int[] parent;
	
	private static int nextHop;
	private static int servPort;
	private static String servDcXX;
	

	public static int randInt(int min, int max)
	{
		Random rand = new Random();
		int randomNum = rand.nextInt((max-min) + 1) + min;
		return randomNum;
	}
	
	@SuppressWarnings("unchecked")
	public static void main(String args[])
	{
		
		//Proj2
		BlockingQueue<String> recvQueue = new LinkedBlockingQueue<String>();
		//BlockingQueue<String> sendQueue = new LinkedBlockingQueue<String>();
		int[] arrPort;
		String[] arrDcxx;
		//End Proj2
		parent = new int[1];
		leaf = new boolean[1];
		parent[0]=-1;
		leaf[0] = false;
		int[] adjMatrix;
		boolean[] state = new boolean[1];
		state[0] = false;
		
		nodes = Integer.parseInt(args[2]);
		
		
		

		//int[] matrix;
		adjMatrix = new int[nodes*nodes];
		arrPort = new int[nodes];
		arrDcxx = new String[nodes];
		nodeId = Integer.parseInt(args[0]);
		String path = new String("");
		

		for(int i=0;i<nodes;i++){
			arrPort[i]=0;
			arrDcxx[i]="";
			for(int j=0;j<nodes;j++){
				adjMatrix[nodes*i+j]=0;
			}
		}
		/*	
		String[] dc;
		dc = new String[nodes];
		int[] prt = new int[nodes];
		int tokenNumber = 0;
		int totalTokens = 1;
		int hopNumber = 1;
		int totalHops = 0;
		int rand = randInt(1,10);
		
		String netId = "rxd132730";
		String config_file = args[4];
		String config = config_file.split(".txt")[0];
		config = config.split("/")[config.split("/").length-1];
		System.out.println("name of config: "+config);
		//System.out.println(config_file.split(".txt")[0]);
		String fileName = config+"-"+netId+"-"+nodeId+".out";
		String midLine = "Node ID: "+nodeId;
		String firstLine = "# BEGIN filename: "+fileName;
		String secondLine = "Net ID: "+netId;
		String thirdLine = "Listening on "+args[3]+":"+args[1];
		String fourthLine = "Random number: "+rand;
		String writeLine;
		FileWriter fw = null;
		BufferedWriter bw = null;
		File file1 = new File(fileName);
	
		try{
			if(!file1.exists()){
				file1.createNewFile();
			}
			fw = new FileWriter(file1,true);
			bw = new BufferedWriter(fw);
			synchronized(bw){
				bw.write(firstLine);
				bw.newLine();
				bw.write(secondLine);
				bw.newLine();
				bw.write(midLine);
				bw.newLine();
				bw.write(thirdLine);
				bw.newLine();
				bw.write(fourthLine);
				bw.newLine();
				//bw.write(fifthLine);
				//bw.newLine();
			}
			//String writeLine;
		}catch(IOException exa){
			exa.printStackTrace();
		}

		*/

		//int rand = randInt(1,10);	
		//System.out.println("Random Number Generated by "+nodeId+" is "+rand);
		String netId = "rxd132730";
		String config_file = args[4];
		String config = config_file.split(".txt")[0];
		config = config.split("/")[config.split("/").length-1];
		String fileName = config+"-"+nodeId+".out";
		FileWriter fw = null;
		BufferedWriter bw = null;
		File file1 = new File(fileName);
		File file = new File(config_file);
		/*try{
			if(!file1.exists()){
				file1.createNewFile();
			}
			fw = new FileWriter(file1,true);
			bw = new BufferedWriter(fw);
			//synchronized(bw){
			//WRITE TO FILE HERE <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
				//bw.write("NewLine");
			//}
		}catch(IOException exa){
			exa.printStackTrace();
		}*/
		try{
			if(!file1.exists()){
				file1.createNewFile();
			}
			fw = new FileWriter(file1,true);
			bw = new BufferedWriter(fw);
			
			//Start server thread
			port = Integer.parseInt(args[1]);
			
			Scanner in = new Scanner(file);
			int lineCount = 0;
			nodes=0;
			
			while(in.hasNextLine()){
				String nxt = in.nextLine();
				String currentLine;
				if((nxt.indexOf("#") > 0 || nxt.indexOf("#") == -1) && !nxt.equals("")){
					if(nxt.indexOf("#")>0){
						currentLine = nxt.substring(0,nxt.indexOf("#"));
						//System.out.println(currentLine);
					}else{
						currentLine = nxt;
						//System.out.println(currentLine);
					}
					if(lineCount==0){
						nodes = Integer.parseInt(currentLine.split(" ")[0]);
						numMessages = Integer.parseInt(currentLine.split(" ")[1]);
						delay = Integer.parseInt(currentLine.split(" ")[2]);
						arrPort = new int[nodes];
						arrDcxx = new String[nodes];
						adjMatrix = new int[nodes*nodes];
					}else{
						if(lineCount>0 && lineCount<=nodes){
							arrPort[lineCount-1]=Integer.parseInt(currentLine.split(" ")[2]);
							arrDcxx[lineCount-1]=currentLine.split(" ")[1];
						}
					}
					lineCount +=1;
				}

				//Initialize adjMatrix 
				for(int i=0;i<nodes;i++){
					for(int j=0;j<nodes;j++){
						if(i!=j){
							adjMatrix[nodes*i+j]=1;
						}
					}
				}
				
			}
			
			//BlockingQueue<String> sendQueue = new LinkedBlockingQueue<String>();
			int neighbors=0;
			for(int i=0;i<nodes;i++){
				if(adjMatrix[nodes*nodeId+i]==1){
					neighbors+=1;
				}
			}
			BlockingQueue<String>[] sendQueue = (LinkedBlockingQueue<String>[])new LinkedBlockingQueue<?>[neighbors];
			BlockingQueue<String> tobRx = new LinkedBlockingQueue<String>();
			BlockingQueue<String> tobSnd = new LinkedBlockingQueue<String>();
			BlockingQueue<String> tobMsgRx = new LinkedBlockingQueue<String>();
			BlockingQueue<String> tobMsgSnd = new LinkedBlockingQueue<String>();
			BlockingQueue<String> csSnd = new LinkedBlockingQueue<String>();
			BlockingQueue<String> csRx = new LinkedBlockingQueue<String>();
			BlockingQueue<String> mutexRx = new LinkedBlockingQueue<String>();
			BlockingQueue<String> mutexSnd = new LinkedBlockingQueue<String>();
			
			//Variables for Chandy Lamport
			int[] channelState = new int[neighbors];
			int[] recording = new int[neighbors];
			int[] vector = new int[nodes];
			int[] systemState= new int[nodes];
			boolean[] snapshot=new boolean[nodes];
			int[] currentNumber=new int[1];	
			int[] countApplnMsg=new int[1];
			int[] protocolTermination=new int[nodes];
			countApplnMsg[0]=0;
			int totalNeighbors = neighbors;
			boolean[] executing=new boolean[1];
			executing[0]=true;

			for(int i=0;i<neighbors;i++){
				channelState[i]=-1;
				recording[i]=-1;
			}

			for(int i=0;i<nodes;i++){
				vector[i]=0;
				snapshot[i]=false;
				protocolTermination[i]=-1;
			}

			for(int i=0;i<neighbors;i++){
				sendQueue[i] = new LinkedBlockingQueue<String>();
			}

			goServer goS = new goServer("Server Thread "+ "node :"+nodeId,port,nodeId,recvQueue);
			goS.start();
			goWorker goW = new goWorker("Worker Thread "+ "node :"+nodeId, nodeId,  recvQueue, sendQueue, adjMatrix, 
					nodes, tobMsgRx, tobMsgSnd, mutexRx, mutexSnd);
			goW.start();
			goApplication goA = new goApplication("Application Thread "+ "node :"+nodeId,nodeId, bw, fw, delay, config_file, numMessages 
					, tobRx, tobSnd, nodes);
			goA.start();
			goTOBroadcast goTOB = new goTOBroadcast("Total Order Broadcast Thread "+ "node :"+nodeId
					,nodeId, tobRx, tobSnd, numMessages, nodes, csSnd, csRx, tobMsgRx, tobMsgSnd);
			goTOB.start();
			goMutex goM = new goMutex("Mutex Thread "+ "node :"+nodeId, nodeId, csSnd, csRx, mutexRx, mutexSnd, nodes);
			goM.start();
			minPerActive=maxPerActive;
			neighbors=0;
			int workers=0;
			for(int k=0;k<nodes;k++){
				if(adjMatrix[nodes*nodeId+k]==1){
					servPort = arrPort[k];
					servDcXX = arrDcxx[k];
					goClient goC = new goClient();
					goC.setThreadName("ClientThread running on "+nodeId);
					goC.setPort(servPort);
					goC.setDcXX(servDcXX);
					goC.setSend(sendQueue[neighbors]);
					goC.start();
					neighbors +=1;
				}
			}
		}
		catch(IOException exb){
			exb.printStackTrace();
		}
	}
} 
